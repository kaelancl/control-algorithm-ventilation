%Parameters for Simscape Model
clear all
tic
simTime = 140;
t = [0:0.01:(simTime-0.01)];

%load('PmusHatSmoothNorm_30_10.mat')

%PmusHatSmoothNorm = PmusHatSmoothNorm(1:end-1);
%plot(PmusHatSmoothNorm)
%hold off

%VENTILATOR SETTINGS
PEEP = 8.5; %cmH2O, Posistive End Expiratory Pressure
Paw_Ref = 13.5; %Pressure target, cmH_2O

%Reference support target changes after 60s
Paw_Ref_in = [t', ones(length(t),1)*Paw_Ref];
Paw_Ref_in(7000:end,2) = Paw_Ref+2;
PS = Paw_Ref - PEEP;

maxAllowableChange = 10; %+- max allowed change in pressure support (cmH2O)
Paw_Threshold = -1; %cmH2O, trigger variable
Q_Threshold_Percentage = 0.3; %percent of peak flow, cycling off variable
numOfBreaths = 20; %number of tidal breaths until support adjust

timeInspVent = 2;
timeExpVent = 2;

cutInValue = 13;
alpha = -1/(cutInValue-15);
zeta = 0.3258;
beta = 3.2576;

%CONTROLLER
%PID
Kp =100; %Proportional constant, PID cntrol
Ti = 0.5; %Integral time constant, PID control
D = 0; %Derivative constant, PID control

P = 1;
I = 1;
D = 0;


%Adjustment Support Level Filter
timeResponse = 25; %time response of system, amount of time for controller
%adjust support level

%Muscle Pressure Adjustment Curve Parameters
gradPmus = 2.5; %gradient of muscle pressure support level adjustment curve
yIntPmus = -20; %y intercept
a1 = 0.1; %gain for driving pressure driven support level adjustment
%Driving Pressure Adjustment
gradDrivePres = 2.5;
yIntDrivePres = -32.5;
a2 = 0.1; %gain for muscle pressure driven support level adjustment

%INITIAL PATIENT SETTINGS
Resistance = 16.25; %cmH2O/L/s
Compliance = 1/36.56; %L/cmH2O
%initialMaxEffort = 10.5; %-cmH2O, initial maximum effort of patient
%maximum effort changes as PSV level changes
timeInsp = 1.4; %patient inspiration time, seconds
timeExp = 2.6; %patient expiration, seconds

varPE = 10; % %change in variation effort (relative to max effort)

%OCCLUSION SETTINGS
%end expiratory occlusion
lengthEEOcc = 5; %Length of end-expiratory occlusion (seconds)
breathsTillEE = 3; %number of breaths that occur before EE occlusion
numberOfRecordingsEE = 3;

%end inspiratory occlusion
numberOfRecordingsEI = 3; %number of recordings till support level adjusted
lengthEIOcc = 1.5; %Length of end-inspiratory occlusion (seconds)
flowOccThreshold = 0.05; %percentage of peak flow when occlusion triggered
breathsTillEI = 3; %number of breaths that occur before EI occlusion


%state (and inverse state signal)
tCounter = 0;
state = zeros(1,length(tCounter));
invState = zeros(1,length(tCounter));
mode = zeros(1,length(tCounter));
breathCounter = 0;
x = 0;
Pmus = zeros(1,length(tCounter));
flowIndexEnable = zeros(1,length(tCounter));

for idx=1:length(t)
    if tCounter < timeInspVent
        state(idx) = 1;
        invState(idx) = 0;
        mode(idx) = 1;
        flowIndexEnable(idx) = 1;
    end
    %expiration
    if breathCounter == 100000
        if tCounter >= timeInspVent && tCounter < (timeInspVent + lengthEIOcc)
            state(idx) = 0;
            invState(idx) = 0;
            mode(idx) = 2;
            
              if tCounter < (timeInspVent + 0.1)
                flowIndexEnable(idx) = 1;
              else
                  flowIndexEnable(idx) = 0;
              end
        end
        if tCounter > (timeInspVent + lengthEIOcc) && tCounter < (timeInspVent + timeExpVent + lengthEIOcc)
            state(idx) = 0;
            invState(idx) = 1;
            mode(idx) = 0;
        end
        if tCounter >= (timeInspVent + timeExpVent + lengthEIOcc)
            tCounter = 0;
            breathCounter = 0;
        end
    else
        if tCounter >= timeInspVent && tCounter < (timeInspVent + timeExpVent)
            state(idx) = 0;
            invState(idx) = 1;
            mode(idx) = 0;
            if tCounter < (timeInspVent + 0.1)
                flowIndexEnable(idx) = 1;
            else 
                flowIndexEnable(idx) = 0;
            end
        end
         if tCounter >= (timeInspVent + timeExpVent)
            tCounter = 0;
            breathCounter = breathCounter + 1;
        end
    end
  
    tCounter = tCounter + 0.01;
end




%plot(t(1:2000),-Pmus(1:2000))
effortMode = 0;
if effortMode == 1
    initialMaxEffort = zeros(1, length(t));
    effort_mag = 5;
    x = 0;
    for idx = 1:length(t)
       x = x + 1;
       initialMaxEffort(idx) = effort_mag;
       if x >= 3500
            x = 0;
            effort_mag = effort_mag + 0.5;
       end
        
        % elseif x < 1100
        %     initialMaxEffort(idx) = 5.5;
        % elseif x < 1200
        %     initialMaxEffort(idx) = 6;
        % elseif x < 1300
        %     initialMaxEffort(idx) = 6.5;
        % elseif x < 1400
        %     initialMaxEffort(idx) = 7;
        % elseif x < 1500
        %     initialMaxEffort(idx) = 7.5;
        % elseif x < 1600
        %     initialMaxEffort(idx) = 8;
        % elseif x < 1700
        %     initialMaxEffort(idx) = 8.5;
        % elseif x < 1800
        %     initialMaxEffort(idx) = 9;
        % elseif x < 1900
        %     initialMaxEffort(idx) = 9.5;
        % elseif x < 2000
        %     initialMaxEffort(idx) = 10;
        % elseif x < 2100
        %     initialMaxEffort(idx) = 10.5;
        % elseif x < 2200
        %     initialMaxEffort(idx) = 11;
        % elseif x < 2300
        %     initialMaxEffort(idx) = 11.5;
        % elseif x < 2400
        %     initialMaxEffort(idx) = 12;
        % elseif x < 2500
        %     initialMaxEffort(idx) = 12.5;
        % elseif x < 2600
        %     initialMaxEffort(idx) = 13;
        % elseif x < 2700
        %     initialMaxEffort(idx) = 13.5;
        % elseif x < 2800
        %     initialMaxEffort(idx) = 14;
        % elseif x < 2900
        %     initialMaxEffort(idx) = 14.5;
        % elseif x < 3000
        %     initialMaxEffort(idx) = 15;
        % end
        x = x + 0.01;
    end
    effortIn = [t' initialMaxEffort'];
else
    initialMaxEffort = 13.08;
end


%% Pmus Model
load('pmus_assume_resp_mech_pat_5_1607_0004_insp_only.mat')

%numBreaths = simTime/((length(pmus_model)-1)/100);
%lengthBreath = length(pmus_model)-1;
%startPos = 1;
Pmus = [];
pmus_model(450:end) = 0;
range_eff = 1.56/2;

peaks_array = [
     -11.8028
      -11.7281
      -13.5460
      -13.2098
      -13.0631
      -12.5065
      -12.9590
      -11.6596
      -12.3850
      -12.7251
      -12.7242
      -13.0269
      -12.3684
      -11.7021
      -12.0717
      -12.5948
      -13.0224
      -13.4730
      -12.7643
      -12.4024
        ];

%for idx=1:simTime/7

for idx=1:20
    %randomly shorten/lengthen pmus
    % pos_neg = 0;
    % while pos_neg == 0
    %     pos_neg = randi([-1,1],1);
    % end
    % adjust_length = rand()*range_eff;
    % length_eff = 700 + (pos_neg*adjust_length*100)
    % % renormalise length to 1 second
    % t_old = linspace(1,700,700);
    % t_new = linspace(1,length_eff,700);
    % 
    % % Normalize time for interpolation
    % tau = t_old / 700;
    % tau_new = t_new / 300;
    % 
    % Pmus_stretched = interp1(tau, pmus_model, tau_new, 'spline');
    % if length(Pmus_stretched) >= 700
    %     Pmus_stretched = Pmus_stretched(1:700);
    % else
    %     length_stretched_eff = length(Pmus_stretched);
    %     Pmus_stretched = Pmus_stretched + zeros(2,700 - length_stretched_eff);
    % end
    Pmus = [Pmus pmus_model*peaks_array(idx)];
    %startPos = startPos + lengthBreath;
    %Pmus(startPos+1:startPos+231) = 0;
    %startPos = startPos + 231;
end


stateIn = [t',state'];
invStateIn = [t',invState'];
Pmus_in = [t', Pmus(1:end)'];
%modeIn = [t', mode'];


%% Patient Response Variables

m = -0.825;
ratioPV = ones(1, length(t))*m;
ratioPV_in = [t', ratioPV'];
c = 23.56;

initial_peak_effort = -7.6;
% C_prop_values = zeros(size(state,2),1);
% C_prop_values(200200:end) = 2;
% C_prop_in = [t', C_prop_values];

C_prop_init = 0; %propofol concentration [ug*mL^-1]

%lookup table
PS_array = [
    13.5000
   14.0000
   14.5000
   15.0000
   15.5000
   16.0000
   16.5000
   17.0000
   17.5000
   18.0000
   18.5000
   19.0000
   19.5000
   20.0000
   20.5000
   21.0000
    ];

%PS_array = PS_array - PEEP;
C_prop_vector = [
0.0
0.5
1.0
1.5
2.0
];

%%
% pmus_array = zeros(5,16);
% counter =1;
% for i = 1:5
%     pmus_array(i,:) = final_results.P_mus(counter:counter + 15);
%     counter = counter + 16;
% end

% pmus_array = ...
% [9.07450995173817	8.58303374254441	8.09163589060172	7.60031522437297	7.10907009752719	6.61789821112623	6.12679635026677	5.63575998296837	5.14478262919641	4.65385483003553	4.16296238629128	3.67208318099328	3.18118105032235	2.69019291238860	2.22194997280716	1.77066793460113;...
% 8.32712845152772	7.86084961938944	7.39466034016806	6.92884796077444	6.46285558675153	5.99709025307945	5.53111826594518	5.06536276765490	4.59963934902614	4.13385453994266	3.66818546991775	3.20246679761484	2.73672332433147	2.27050988208754	1.85508365411562	1.47727018951182;...
% 7.57960998886679	7.13840128992502	6.69730279182784	6.25713070167087	5.81612331222786	5.37548174765759	4.93468252706403	4.49420422606204	4.05354609517805	3.61258158085774	3.17161584615783	2.73034796123167	2.28799731183129	1.84309533118342	1.47667746892257	1.16983539531106;...
% 6.83134879540383	6.41506974668250	5.99988944823208	5.58422101329840	5.16863690252799	4.75343725022152	4.33722350841555	3.92134974234469	3.50516855183661	3.08844931876491	2.67049382603472	2.24997798355149	1.82327893510971	1.37930157594579	1.02912256572725	0.771692094620232;...
% 6.08230484830341	5.69099234298216	5.30101725337789	4.91020628198063	4.51940179029062	4.12771651843734	3.73617781747217	3.34395172543840	2.95065125236925	2.55454321303406	2.15205220709006	1.73582091734394	1.26073612937778	0.178310121249703	0.161288355039994	0.176538749852994];
% pmus_array = [ 8.20204957054159	7.32242790702433	6.44294674627587	5.56359910535969	4.68437552537292	3.80526310158453	2.92624402235858	2.04729329963991	1.16837511551261	0.289436687410667	-0.589602569109148	-1.46887141285441	-2.34858819284575	-3.22915408880192	-4.11139450682888
%                6.81939832440088	6.00702797363857	5.19485905988810	4.38245590564013	3.57138089144814	2.75966113214197	1.94803670660808	1.13653599643584	0.325123327178011	-0.486042602785643	-1.29742594395878	-2.10868313736779	-2.91974871960946	-3.73143941374635	-4.54394259750470
%                5.43596384113983	4.69160339514572	3.94644129106458	3.20150003531486	2.45669470333373	1.71256819090272	0.969335740945855	0.224162440644013	-0.519745322800808	-1.26391365529010	-2.00775556444939	-2.75190891304196	-3.49563896524207	-4.23944141993544	-4.98273278554627
%                4.05366584338615	3.37485545256848	2.69611675166603	2.01649349059161	1.34004544806284	0.662478874219780	-0.0163273270637649	-0.693507513453920	-1.37212022240480	-2.05016804966536	-2.72829695649435	-3.40729719176979	-4.08593749981891	-4.76343101579639	-5.43564879438139
%                2.66285224428526	2.05133755061735	1.43779467268909	0.825623120318754	0.213988653624690	-0.398960234164902	-1.01339816602447	-1.62759775426062	-2.24221867752059	-2.85968180041889	-3.47747806746358	-4.09838968119663	-4.71496288288944	-5.32052261988318	-5.90203546365517
%     ];

pmus_array = [16.3452467583878	15.4808842835195	14.6167666703845	13.7528897794029	12.8892477027058	12.0258321162512	11.1626313293298	10.2996288525953	9.43680117368215	8.57411417633035	7.71151712734586	6.84893205432843	5.98623377712642	5.12320931298711	4.25946648412698	3.39419730602994
14.9627854059974	14.1631826762944	13.3630810950498	12.5632186353776	11.7632116025272	10.9645811089964	10.1653790487922	9.36641030127103	8.56761299999942	7.76894474570894	6.97059846750354	6.17207176370893	5.37366413097156	4.57538754665812	3.77637878590432	2.97632891355907
13.5799516894360	12.8431333371436	12.1077763413071	11.3717098518412	10.6358552096156	9.90015388570647	9.16531814570693	8.43127965989575	7.69537062253972	6.96071153787871	6.22564820804992	5.49088504710751	4.75555348229820	4.02031947518171	3.28444419365462	2.54836405960178
12.1926635598792	11.5224396904083	10.8494706560974	10.1765496423470	9.50273667074635	8.83225924689844	8.16039565400805	7.48728039246077	6.81578365979207	6.14266810280606	5.46984915517259	4.79646714287231	4.12160244131732	3.44628056664401	2.77093248858069	2.10004864405077
10.8016106110467	10.1909954504217	9.58206774047811	8.97121502048006	8.36155678094883	7.75227022501360	7.14157051333851	6.52905526112818	5.91649849433299	5.30301214494430	4.68596557462044	4.06755174292472	3.44446261719359	2.82437019617287	2.21438224939608	1.63000227404089];

ind_neg = find(pmus_array<0);
pmus_array(ind_neg) = 0;
pmus_array = pmus_array .* -1;

p_dyn_array = zeros(size(pmus_array));

for i = 1:size(p_dyn_array,1)
    for j = 1:size(p_dyn_array,2)
        p_dyn_array(i,j) = (PS_array(j)-PEEP)-(pmus_array(i,j)*2/3);
    end
end

%% color map Pdyn

figure()
imagesc(p_dyn_array)
caxis([8 14]);

% Create custom greenâ†’red colormap
nColors = 256;
green = [0, 1, 0];  % RGB for green
red   = [1, 0, 0];  % RGB for red
customMap = [linspace(green(1), red(1), nColors)', ...
             linspace(green(2), red(2), nColors)', ...
             linspace(green(3), red(3), nColors)'];

colormap(customMap);
colorbar;



% S_0 = 0; %receptor sensitivity in hyperoxia [L*min^-1*(nM*L^-1)^-1]
% A = 17.8; %Area constant
% P_o2 = 100; %partial pressure of oxygen
% P_0 = 30; %P_o2 max sensitivity beffore receptor failure
% T_c = 40; %central receptors threshold [nM L-1]
% T_p = 34.6; %peripheral receptor threshold [nM L-1]
% F_R = 12; %respiratory rate [min^-1]
% V_D_anat = 0.12; %anatomical dead space [L]
% V_D_alv_ratio = 0.3; %alveolar dead space to tidal volume ratio
% dot_V_TH = 0.2689; %flow threshold [L*s^-1]
% D_w = 0; %wakefulness drive (0 = asleep)
% Na_conc = 0.139;
% K_conc = 0.0043;
% Ca_conc = 0.0012;
% Mg_conc = 0.00085;
% Alb = 4.5;
% Pi = 0.00012;
% HCO3_conc = 0.024; %nM*L-1
% V_co2 = 0.2; %L * min^-1
% T_i = 0.978; %Inspiration time [s]
% Cl_conc = 0.105; %Chlorine concentration [M*L^-1]
% K_w = 2.39e-14; %ion product of water 
% K_c = 2.45e-11; %equilibrium constant
% K_2 = 2.19e-7; %phosphoric acid dissociation constant
% K_3 = 1.16e-10; %carbonate dissocation constant
% K_h = 1.77e-7; %histidine dissociation constant
% 
% PEEP = 6; %cmH2O, Posistive End Expiratory Pressure
% Resistance = 11.2; %cmH2O/L/s
%Compliance = 0.0617; %L/cmH2O
% figure()
% plot(t, mode')
% 
% figure()
% plot(t, state')
% 
% figure()
% plot(t, invState')
% 
% figure()
% plot(t, Pmus')
% plot(t, state)
% hold on
% plot(t, invState)
% plot(t, Pmus)
% plot(t, mode)

% plot(modeIn, 'Color', 'r')    
% hold on
% plot(flowIndexEnableIn, 'Color', 'g')
% hold off

%SIMULATE MODEL
%simOut = sim("simplePatientModelTuning_30_08_23.slx");
% simOut = sim("simScapeModel_tuning_08_23.slx")
% %DETERMINE IAE
% %take average of last set point values from 380 seconds onwards
% % ssIndStart = find(simOut.adjustedSetPoint.time > 400,1);
% % ssValue = mean(simOut.adjustedSetPoint.data(ssIndStart:end));
% % 
% % changeFlagTime = simOut.changeFlag.time(find(simOut.changeFlag.data ~= 0));
% % changeFlagTime = round(changeFlagTime*100)/100;
% % changeFlagTime = unique(changeFlagTime);
% % for idx=2:length(changeFlagTime)
% %     if abs(diff([changeFlagTime(idx) changeFlagTime(idx-1)])) < 0.1
% %         changeFlagTime(idx) = 0;
% %     end
% % end
% % changeFlagTimeProcessed = changeFlagTime(find(changeFlagTime ~= 0));
% % IAE = 0;
% % IAE_array = [];
% % 
% % %DOESN"T QUITE WORK, I THINK changeFlagTime is a bit funky
% % % for idx = 1:length(changeFlagTimeProcessed)
% % %     IAE = IAE + abs(diff([ssValue simOut.adjustedSetPoint.data(find(simOut.adjustedSetPoint.time > changeFlagTimeProcessed(idx),1))]));
% % %     IAE_array = [IAE_array; IAE];
% % % end
% % 
% % for idx = 1:length(changeFlagTimeProcessed)
% %     IAE = IAE + abs(diff([ssValue simOut.adjustedSetPoint.data(find(simOut.adjustedSetPoint.time > changeFlagTimeProcessed(idx),1))]));
% %     IAE_array = [IAE_array; IAE];
% % end
% % 
% plot(simOut.adjustedSetPoint.time,simOut.adjustedSetPoint.data)
% hold on
% % plot(changeFlagTimeProcessed, IAE_array)
% % toc
% 
% %SETTLING TIME
% PSVout= simOut.adjustedSetPoint.data;
% TimeOut = simOut.adjustedSetPoint.time;
% ssValue = PSVout(end);
% upper = yline(ssValue + (0.02*ssValue))
% lower = yline(ssValue - (0.02*ssValue))
% diffFromSS = abs(PSVout - ssValue);
% ssBand = ssValue*0.02;
% settlingTime = TimeOut(find(diffFromSS > ssBand,1, 'last')) 
% settlingPoint = PSVout(find(TimeOut == settlingTime))
% plot(settlingTime, settlingPoint, '-o')
% %settlingTimeIdx = find(abs(diff([reversePSV(1) reversePSV])) > 0.05*reversePSV(1))


% selectPmus = 1;
% %Base Pmus signal
% breathCounter = 0;
% cycleCounter = 1;
% a = [1.2 1.5 2 3 6];
% b = [6 3 2 1.5 1.2];
% c = [0.05:0.05:0.75];
% d = [0.1:0.1:1.5];
% e = [2:0.5:6];
% 
% switch selectPmus
%     case 1 %half sine wave    
%         for idx = 1:length(t)
%             if x <= timeInsp %patient effort during inspiration
%                 Pmus(idx) = sin(x/timeInsp*pi);
%             end
% 
%             if breathCounter == 3
%                 if x > timeInsp && x <= (timeInsp + timeExp + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (timeInsp + timeExp + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                 end
%             else
%                 if x > timeInsp && x <= timeInsp + timeExp %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > timeInsp + timeExp %reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01; %increment timer
%         end
% 
%     case 2 %flipped halfwave
% 
%         Tip = 0.5;
%         Te = 1.5;
%         Tep = 2;
%         Tnext = 4;
% 
%         for idx = 1:length(t)
%             if x <Tip
%                 Pmus(idx) = -sin(((x)*pi)/(2*(-Tip)));
%             end
%             if  x >= Tip && x < Te
%                 Pmus(idx) = 1;
%             end
% 
%              if x >= Te && x < Tep
%                 Pmus(idx) = sin(((x-Te)*pi)/(2*(Tep-Te))+pi)+1 ;
%              end         
%             if breathCounter == 3
%                 if x > Tep && x <= (Tnext + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (Tnext + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                 end
%             else
%                  if x >=Tep && x < Tnext
%                     Pmus(idx) = 0;
%                  end
%                 if x >= Tnext
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01;
%         end
% 
%     case 3 %square wave    
%         for idx = 1:length(t)
%             if x <= timeInsp %patient effort during inspiration
%                 Pmus(idx) = 1;
%             end
% 
%             if breathCounter == 3
%                 if x > timeInsp && x <= (timeInsp + timeExp + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (timeInsp + timeExp + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                 end
%             else
%                 if x > timeInsp && x <= timeInsp + timeExp %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > timeInsp + timeExp %reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01; %increment timer
%         end
% 
%     case 4 %saw tooth
%         for idx = 1:length(t)
%             if x <= timeInsp %patient effort during inspiration
%                 if x<= timeInsp/2
%                      Pmus(idx) = 4/3*x;
%                 elseif x > timeInsp/2
%                     Pmus(idx) = -4/3*x+2;
%                 end
%             end
% 
%             if breathCounter == 3
%                 if x > timeInsp && x <= (timeInsp + timeExp + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (timeInsp + timeExp + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                 end
%             else
%                 if x > timeInsp && x <= timeInsp + timeExp %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > timeInsp + timeExp %reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01; %increment timer
%         end
% 
%     case 5 %sawtooth shifting peak
%         for idx = 1:length(t)
%             if x <= timeInsp %patient effort during inspiration
%                Pmus(idx) = min(-a(cycleCounter)/timeInsp*x+a(cycleCounter),b(cycleCounter)*x/timeInsp);
% 
%             end
% 
%             if breathCounter == 3
%                 if x > timeInsp && x <= (timeInsp + timeExp + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (timeInsp + timeExp + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                     cycleCounter = cycleCounter + 1;
%                     if cycleCounter > 5
%                         cycleCounter = 5;
%                     end
%                 end
%             else
%                 if x > timeInsp && x <= timeInsp + timeExp %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > timeInsp + timeExp %reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01; %increment timer
%         end
% 
%     case 6 %short triangle
%         for idx = 1:length(t)
%             if x <= timeInsp %patient effort during inspiration
% 
%                Pmus(idx) = min(1/0.125*x-5,-x/0.125+7);
%                Pmus(idx) = max(Pmus(idx),0);
% 
%             end
% 
%             if breathCounter == 3
%                 if x > timeInsp && x <= (timeInsp + timeExp + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (timeInsp + timeExp + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                     cycleCounter = cycleCounter + 1;
%                     if cycleCounter > 5
%                         cycleCounter = 5;
%                     end
%                 end
%             else
%                 if x > timeInsp && x <= timeInsp + timeExp %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > timeInsp + timeExp %reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01; %increment timer
%         end
%     case 7 %triangle varying lengths
%         for idx = 1:length(t)
%             if x <= timeInsp %patient effort during inspiration
% 
%                Pmus(idx) = min(1/c(cycleCounter)*x,-x/c(cycleCounter)+2);
%                Pmus(idx) = max(Pmus(idx),0);
% 
%             end
% 
%             if breathCounter == 3
%                 if x > timeInsp && x <= (timeInsp + timeExp + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (timeInsp + timeExp + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                     cycleCounter = cycleCounter + 1;
%                     if cycleCounter > 15
%                         cycleCounter = 15;
%                     end
%                 end
%             else
%                 if x > timeInsp && x <= timeInsp + timeExp %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > timeInsp + timeExp %reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01; %increment timer
%         end
%     case 8 %sinusoidal wave varying lengths
%         for idx = 1:length(t)
%             if x <= timeInsp %patient effort during inspiration
%                if x < d(cycleCounter)
%                     Pmus(idx) = sin(pi/d(cycleCounter)*x);
%                else 
%                    Pmus(idx) = 0;
%                end
%             end
% 
%             if breathCounter == 3
%                 if x > timeInsp && x <= (timeInsp + timeExp + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (timeInsp + timeExp + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                     cycleCounter = cycleCounter + 1;
%                     if cycleCounter > 15
%                         cycleCounter = 15;
%                     end
%                 end
%             else
%                 if x > timeInsp && x <= timeInsp + timeExp %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > timeInsp + timeExp %reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01; %increment timer
%         end
% 
%     case 9 %triangle wave varying lengths, capped at 1
%         for idx = 1:length(t)
%             if x <= timeInsp %patient effort during inspiration
%               Pmus(idx) = min([1/0.25*x,-x/0.25+e(cycleCounter),1]);
%                Pmus(idx) = max(Pmus(idx),0);
%             end
% 
%             if breathCounter == 3
%                 if x > timeInsp && x <= (timeInsp + timeExp + lengthEIOcc) %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > (timeInsp + timeExp + lengthEIOcc)%reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = 0;
%                     cycleCounter = cycleCounter + 1;
%                     if cycleCounter > 9
%                         cycleCounter = 9;
%                     end
%                 end
%             else
%                 if x > timeInsp && x <= timeInsp + timeExp %patient effort during expiration
%                     Pmus(idx) = 0;
%                 end
% 
%                 if x > timeInsp + timeExp %reset timer after 2 seconds has passed
%                     x = 0;
%                     breathCounter = breathCounter + 1;
%                 end
%             end
%             x = x + 0.01; %increment timer
%         end
%     case 10 %B-Spline function from patient data
%         numBreaths = simTime/((length(pmus_model)-1)/100);
%         lengthBreath = length(PmusHatSmoothNorm)-1;
%         startPos = 1;
%         for idx=1:simTime/4
%             Pmus(startPos:startPos + lengthBreath) = PmusHatSmoothNorm;
%             startPos = startPos + lengthBreath;
%             Pmus(startPos+1:startPos+231) = 0;
%             startPos = startPos + 231;
%         end
% end


